flekspy
=======

.. py:module:: flekspy

.. autoapi-nested-parse::

   flekspy Public API.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/flekspy/amrex/index
   /autoapi/flekspy/flekspy/index
   /autoapi/flekspy/idl/index
   /autoapi/flekspy/plot/index
   /autoapi/flekspy/tp/index
   /autoapi/flekspy/util/index
   /autoapi/flekspy/yt/index


Classes
-------

.. autoapisummary::

   flekspy.IDLAccessor
   flekspy.YtFLEKSData
   flekspy.FLEKSTP
   flekspy.AMReXParticleData


Functions
---------

.. autoapisummary::

   flekspy.read_idl
   flekspy.extract_phase
   flekspy.load


Package Contents
----------------

.. py:function:: read_idl(filename)

   Read IDL format file.


.. py:class:: IDLAccessor(xarray_obj)

   .. py:attribute:: _obj


   .. py:method:: get_slice(norm, cut_loc) -> xarray.Dataset

      Get a 2D slice from the 3D IDL data.
      :param norm: The normal direction of the slice from "x", "y" or "z"
      :type norm: str
      :param cur_loc: The position of slicing.
      :type cur_loc: float

      Return: xarray.Dataset



.. py:class:: YtFLEKSData(output_dir, read_field_data=False, cparam_filename=None, fparam_filename=None, dataset_type='boxlib_native', storage_filename=None, units_override=None, unit_system='mks')

   Bases: :py:obj:`yt.frontends.boxlib.api.BoxlibDataset`


   Read and plot the AMReX format output from FLEKS.

   :param output_dir: the path to the data.
   :type output_dir: str

   .. rubric:: Examples

   >>> import flekspy
   >>> ds = flekspy.YtFLEKSData("3d_particle*n00004750_amrex")


   .. py:attribute:: _index_class


   .. py:attribute:: _field_info_class


   .. py:attribute:: default_fluid_type
      :value: 'mesh'



   .. py:attribute:: default_field
      :value: ('mesh', 'density')



   .. py:attribute:: fluid_types
      :value: ('mesh', 'index', 'raw')



   .. py:attribute:: read_field_data
      :value: False



   .. py:method:: _parse_parameter_file()

      Parses the parameter file and establishes the various
      dictionaries.



   .. py:method:: _set_code_unit_attributes()


   .. py:method:: pvar(var)


   .. py:method:: get_slice(norm, cut_loc) -> flekspy.util.DataContainer2D

      Returns a DataContainer2D object that contains a slice along the normal direction.

      :param norm: slice normal direction in "x", "y" or "z"
      :type norm: str
      :param cut_loc: cut location along the normal direction
      :type cut_loc: float



   .. py:method:: get_domain() -> flekspy.util.DataContainer3D

      Read all the simulation data into a 3D box.



   .. py:method:: plot_slice(norm, cut_loc, vars, unit_type='planet', *args, **kwargs)

      Plot 2D slice

      :param norm: str
                   Normal direction of the slice in "x", "y" or "z".
      :param cut_loc: float
                      The location of the slice.
      :param vars: a list or string of plotting variables.
                   Example: "Bx rhos0" or ["Bx", "rhos0"]

      unit_type: The unit system of the plots. "planet" or "si".

      .. rubric:: Examples

      >>> vars = ["rhos0", "uzs0", "Bz", "pxxs1", "Ex"]
      >>> splt = ds.plot_slice("y", 0.0, vars)
      >>> splt.display()



   .. py:method:: _get_profile(x_field, y_field, z_field, region: yt.data_objects.selection_objects.data_selection_objects.YTSelectionContainer | None = None, x_bins: int = 128, y_bins: int = 128, domain_size: tuple | None = None)


   .. py:method:: get_phase(x_field, y_field, z_field, region: yt.data_objects.selection_objects.data_selection_objects.YTSelectionContainer | None = None, x_bins: int = 128, y_bins: int = 128, domain_size: tuple | None = None)

      Get particle phase space distribution.

      :param region: YTSelectionContainer
                     Spatial region to be selected, such as all_data, box, region, or sphere.
      :param x_field & y_field: string
                                The x-/y- axes, from "p_ux", "p_uy", "p_uz", "p_x", "p_y" or "p_z".
      :param z_field: string
                      It is usually the particle weight: "p_w".
      :param domain_size: tuple
                          Axis range of 4 elements: x_min, x_max, y_min, y_max

      .. rubric:: Examples

      >>> x, y, w = ds.get_phase("p_ux", "p_uy", "p_w", domain_size=(-1, 1, -1, 1))



   .. py:method:: plot_phase(x_field, y_field, z_field, region: yt.data_objects.selection_objects.data_selection_objects.YTSelectionContainer | None = None, unit_type: str = 'planet', x_bins: int = 128, y_bins: int = 128, domain_size: tuple | None = None, font_size: float = 18, figure_size: float = 8, customized: bool = False) -> yt.visualization.profile_plotter.PhasePlot

      Plot particle phase space distribution.

      :param region: YTSelectionContainer
                     Spatial region to be selected, such as all_data, box, region, or sphere.
      :param x_field & y_field: string
                                The x-/y- axes, from "p_ux", "p_uy", "p_uz", "p_x", "p_y" or "p_z".
      :param z_field: string
                      It is usually the particle weight: "p_w".
      :param unit_type: string
                        The unit system of the plots. "planet" or "si".
      :param domain_size: tuple
                          Axis range of 4 elements: x_min, x_max, y_min, y_max

      .. rubric:: Examples

      >>> pp = ds.plot_phase("p_ux", "p_uy", "p_w", domain_size=(-1, 1, -1, 1))
      >>> pp.show()



   .. py:method:: plot_particles(x_field, y_field, z_field, region: yt.data_objects.selection_objects.data_selection_objects.YTSelectionContainer | None = None, unit_type: str = 'planet', x_bins: int = 128, y_bins: int = 128, **kwargs)

      Plot the particle position of particles inside a box.

      :param x_field & y_field: str
                                The x- y- axes, from "p_x", "p_y", "p_z".
      :param z_field: str
                      color variable, usually the particle weight "p_w".
      :param region: YTSelectionContainer
                     Spatial region to be selected, such as all_data, box, region, or sphere.
      :param unit_type: str
                        The unit system of the plots. "planet" or "si".

      See more at https://yt-project.org/doc/reference/api/yt.visualization.particle_plots.html#yt.visualization.particle_plots.ParticlePlot

      .. rubric:: Examples

      >>> pp = ds.plot_particles([8, -1, -1], [10, 0, 0], "p_x", "p_y", "p_w", unit_type="planet")
      >>> pp.show()



.. py:function:: extract_phase(pp: yt.visualization.profile_plotter.PhasePlot)

   Extract phase space distribution from PhasePlot object.

   :param pp: YT PhasePlot object.
   :type pp: PhasePlot

   :returns: Horizontal, vertical coordinates of the plot, and phase space density.
   :rtype: x, y, f


.. py:class:: FLEKSTP(dirs: str, iDomain: int = 0, iSpecies: int = 0, unit: str = 'planetary', mass: float = proton_mass, charge: float = elementary_charge, iListStart: int = 0, iListEnd: int = -1, use_cache: bool = False)

   Bases: :py:obj:`object`


   A class that is used to read and plot test particles. Each particle ID consists of
   a CPU index, a particle index on each CPU, and a location index.
   By default, 7 real numbers saved for each step: time + position + velocity.
   Additional field information are also stored if available.

   This class is a lazy, iterable container. It avoids loading all data into memory
   at once, making it efficient for large datasets. You can access particle
   trajectories using standard container operations.

   :param dirs: the path to the test particle dataset.
   :type dirs: str

   Examples:
   >>> tp = FLEKSTP("res/run1/PC/test_particles", iSpecies=1)
   >>> len(tp)
   10240
   >>> trajectory = tp[0]
   >>> tp.plot_trajectory(tp.IDs[3])
   >>> tp.save_trajectory(tp.IDs[5], format="csv")
   >>> tp.save_trajectory(tp.IDs[5], format="parquet")
   >>> ids, pData = tp.read_particles_at_time(0.0, doSave=False)
   >>> f = tp.plot_location(pData)


   .. py:attribute:: use_cache
      :value: False



   .. py:attribute:: unit
      :value: 'planetary'



   .. py:attribute:: _trajectory_cache


   .. py:attribute:: mass


   .. py:attribute:: charge


   .. py:attribute:: iSpecies
      :value: 0



   .. py:attribute:: pfiles
      :value: []



   .. py:attribute:: particle_locations
      :type:  Dict[Tuple[int, int], List[Tuple[str, int]]]


   .. py:attribute:: IDs


   .. py:attribute:: filetime
      :value: []



   .. py:method:: __repr__()


   .. py:method:: __len__()


   .. py:method:: __iter__()


   .. py:method:: __getitem__(key)


   .. py:method:: getIDs()


   .. py:method:: read_particle_list(filename: str) -> Dict[Tuple[int, int], int]

      Read and return a list of the particle IDs.



   .. py:method:: _read_the_first_record(filename: str) -> Union[List[float], None]

      Get the first record stored in one file.



   .. py:method:: read_particles_at_time(time: float, doSave: bool = False) -> Tuple[numpy.ndarray, numpy.ndarray]

      Get the information of all the particles at a given time.
      If doSave, save to a CSV file with the name "particles_t***.csv".

      Note that the time tags in filetime do not include the last saved time.

      :returns: a numpy array of tuples contains the particle IDs.
                pData: a numpy real array with the particle weight, location and velocity.
      :rtype: ids

      Examples:
      >>> ids, pData = pt.read_particles_at_time(3700, doSave=True)



   .. py:method:: save_trajectory(pID: Tuple[int, int], filename: str = None, shiftTime: bool = False, scaleTime: bool = False, format: str = 'csv') -> None

      Save the trajectory of a particle to a file.
      :param pID: particle ID.
      :param filename: The name of the file to save the trajectory to.
                       If None, a default name will be generated.
      :type filename: str, optional
      :param shiftTime: If set to True, set the initial time to be 0.
      :type shiftTime: bool
      :param scaleTime: If set to True, scale the time into [0,1] range.
      :type scaleTime: bool
      :param format: The output format, either "csv" or "parquet".
      :type format: str

      Example:
      >>> tp.save_trajectory((3,15), format="parquet")



   .. py:method:: save_trajectories(pIDs: Union[List[Tuple[int, int]], List[int]], filename: str = 'trajectories.h5') -> None

      Save the trajectories of multiple particles to a single HDF5 file.

      :param pIDs: A list of particle IDs to save. This can be a list of tuples
                   (cpu, id) or a list of integer indices.
      :param filename: The name of the HDF5 file to save the trajectories to.
      :type filename: str



   .. py:method:: _get_particle_raw_data(pID: Tuple[int, int]) -> numpy.ndarray

      Reads all raw trajectory data for a particle across multiple files.



   .. py:method:: _read_particle_record(pID: Tuple[int, int], index: int = -1) -> Union[list, None]

      Return a specific record of a test particle given its ID.

      :param pID: particle ID
      :param index: The index of the record to be returned.
                    0: first record.
                    -1: last record (default).



   .. py:method:: read_particle_trajectory(pID: Tuple[int, int]) -> polars.LazyFrame

      Return the trajectory of a test particle as a polars LazyFrame.



   .. py:method:: read_initial_condition(pID: Tuple[int, int]) -> Union[list, None]

      Return the initial conditions of a test particle.



   .. py:method:: read_final_condition(pID: Tuple[int, int]) -> Union[list, None]

      Return the final conditions of a test particle.



   .. py:method:: select_particles(f_select: Callable = None) -> List[Tuple[int, int]]

      Return the test particles whose initial conditions satisfy the requirement
      set by the user defined function f_select. The first argument of f_select is the
      particle ID, and the second argument is the ID of a particle.

      Examples:
      >>> from flekspy.tp import Indices
      >>> def f_select(tp, pid):
      >>>     pData = tp.read_initial_condition(pid)
      >>>     inTime = pData[Indices.TIME] < 3601
      >>>     inRegion = pData[Indices.X] > 20
      >>>     return inTime and inRegion
      >>>
      >>> pselected = tp.select_particles(f_select)
      >>> tp.plot_trajectory(list(pselected.keys())[1])



   .. py:method:: get_kinetic_energy(vx, vy, vz)


   .. py:method:: get_kinetic_energy_change_rate(pt_lazy: polars.LazyFrame) -> polars.Series

      Calculates the rate of change of kinetic energy in [eV/s].



   .. py:method:: get_pitch_angle(pID)


   .. py:method:: _get_pitch_angle_lazy(lf: polars.LazyFrame) -> polars.Series
      :staticmethod:


      Calculates the pitch angle from a LazyFrame.



   .. py:method:: get_pitch_angle_from_v_b(vx, vy, vz, bx, by, bz)
      :staticmethod:



   .. py:method:: get_first_adiabatic_invariant(pt_lazy: polars.LazyFrame) -> polars.Series

      Calculates the 1st adiabatic invariant of a particle.
      The output units depend on the input data's units:
      - "planetary" (e.g., velocity in km/s, B-field in nT): result is in [1e9 J/T].
      - "SI" (e.g., velocity in m/s, B-field in T): result is in [J/T].



   .. py:method:: _calculate_bmag(df: Union[polars.DataFrame, polars.LazyFrame]) -> Union[polars.DataFrame, polars.LazyFrame]
      :staticmethod:


      Calculates the magnetic field magnitude.



   .. py:method:: _calculate_curvature(df: Union[polars.DataFrame, polars.LazyFrame]) -> Union[polars.DataFrame, polars.LazyFrame]
      :staticmethod:


      Calculates the magnetic field curvature vector and adds it to the DataFrame.
      κ = (b ⋅ ∇)b
      Depending on the selected units, output curvature may be
      - "planetary": [1/RE]
      - "SI": [1/m]



   .. py:method:: get_ExB_drift(pt_lazy: polars.LazyFrame) -> polars.DataFrame

      Calculates the convection drift velocity for a particle.
      v_exb = E x B / (B^2)
      Assuming Earth's planetary units, output drift velocity in [km/s].



   .. py:method:: get_curvature_drift(pt_lazy: polars.LazyFrame) -> polars.DataFrame

      Calculates the curvature drift velocity for a particle.
      v_c = (m * v_parallel^2 / (q*B^2)) * (B x κ)
      Depending on the selected units, output drift velocity may be
      - "planetary": [km/s]
      - "SI": [m/s]



   .. py:method:: get_adiabaticity_parameter(pt_lazy: polars.LazyFrame) -> polars.Series

      Calculates the adiabaticity parameter, defined as the ratio of the
      magnetic field's radius of curvature to the particle's gyroradius.
      When this parameter is >> 1, the motion is adiabatic.



   .. py:method:: _calculate_gradient_b_magnitude(df: Union[polars.DataFrame, polars.LazyFrame]) -> Union[polars.DataFrame, polars.LazyFrame]
      :staticmethod:


      Calculates the gradient of the magnetic field magnitude.



   .. py:method:: get_gradient_drift(pt_lazy: polars.LazyFrame) -> polars.DataFrame

      Calculates the gradient drift velocity for a particle.
      v_g = (μ / (q * B^2)) * (B x ∇|B|)
      Depending on the selected units, output drift velocity may be
      - "planetary": [km/s]
      - "SI": [m/s]



   .. py:method:: get_polarization_drift(pt_lazy: polars.LazyFrame) -> polars.DataFrame

      Calculates the polarization drift velocity for a particle.
      v_p = (m / (q * B^2)) * (dE_perp / dt)
      Depending on the selected units, output drift velocity may be
      - "planetary": [km/s]
      - "SI": [m/s]



   .. py:method:: get_betatron_acceleration(pt, mu)

      Calculates the Betatron acceleration term from particle trajectory data.

      The calculation follows the formula: dW/dt = μ * (∂B/∂t)
      where the partial derivative is found using: ∂B/∂t = dB/dt - v ⋅ ∇B

      :param pt: A Polars LazyFrame containing the particle trajectory.
                 It must include columns for time, velocity (vx, vy, vz),
                 magnetic field (bx, by, bz), and the magnetic field
                 gradient tensor (e.g., 'dbxdx', 'dbydx', etc.).
      :param mu: A Polars Series containing the magnetic moment (first adiabatic invariant)
                 of the particle.

      :returns: A new Polars LazyFrame with added intermediate columns and the
                final 'dW_betatron' column representing the rate of energy change in [eV/s].



   .. py:method:: get_energy_change_guiding_center(pID: Tuple[int, int]) -> polars.DataFrame

      Computes the change of energy of a single particle based on the guiding center theory.

      The formula is given by:
      dW/dt = q*E_parallel*v_parallel + mu*(∂B/∂t + u_E.∇B) + m*v_parallel^2*(u_E.κ)

      where W is the particle energy, B is the magnetic field magnitude,
      u_E is the E cross B drift, and κ is the magnetic field curvature.
      The first term on the right hand side is the parallel acceleration,
      the second term is the Betatron acceleration, and the third term
      is one type of Fermi acceleration.

      :param pID: The particle ID (cpu, id).
      :type pID: Tuple[int, int]

      :returns: A Polars DataFrame with the time, the three energy change components,
                and the total, in [eV/s].



   .. py:method:: integrate_drift_accelerations(pid: tuple[int, int])

      Compute plasma drift velocities and the associated rate of energy change in [eV/s].



   .. py:method:: analyze_drifts(pid: tuple[int, int], outname=None, switchYZ=False)

      Compute plasma drift velocities and the associated rate of energy change in [eV/s].



   .. py:method:: analyze_drifts_energy_change(pID: Tuple[int, int], outname=None)

      Analyzes and plots the energy changes for each term in the guiding center
      approximation.

      This method computes the parallel, Betatron, and Fermi accelerations using
      `get_energy_change_guiding_center`. It also calculates the total kinetic
      energy change and treats the difference between the kinetic energy change
      and the sum of the guiding center terms (dW_total) as the non-adiabatic term.

      The method generates a plot with four subplots:
      1. dW_parallel: Energy change due to parallel electric fields.
      2. dW_betatron: Energy change due to the Betatron effect.
      3. dW_fermi: Energy change due to Fermi acceleration.
      4. dW_total and Non-adiabatic term: The sum of the above terms compared
         with the non-adiabatic heating component.

      :param pID: The particle ID (cpu, id).
      :type pID: Tuple[int, int]
      :param outname: If provided, the plot is saved to this
                      filename instead of being shown. Defaults to None.
      :type outname: str, optional



   .. py:method:: analyze_drift(pID: tuple[int, int], drift_type: str, outname=None)

      Analyzes a specific drift for a particle, plotting its velocity, the
      electric field, the energy change rate, and the integrated energy change.

      :param pID: The particle ID (cpu, id).
      :type pID: tuple[int, int]
      :param drift_type: The type of drift to analyze. Supported options are:
                         'ExB', 'gradient', 'curvature', 'polarization'.
      :type drift_type: str
      :param outname: If provided, the plot is saved to this
                      filename instead of being shown. Defaults to None.
      :type outname: str, optional



   .. py:method:: plot_work_energy_verification(pID: Tuple[int, int], outname=None)

      Verifies the work-energy theorem for a particle by plotting the rate of
      change of kinetic energy against the work rate done by the electric field.
      It also plots the integrated change in kinetic energy versus the total
      work done.

      :param pID: The particle ID (cpu, id).
      :type pID: Tuple[int, int]
      :param outname: If provided, the plot is saved to this
                      filename. Defaults to None (displays plot).
      :type outname: str, optional



   .. py:method:: find_shock_crossing_time(pid, b_threshold_factor=2.5, verbose=False)

      Finds the shock crossing time for a single particle.

      The shock is identified by finding the first rate of change in the
      magnetic field magnitude that exceeds a threshold, which signifies a
      rapid transition between the upstream and downstream regions.

      :param pid: particle index.
      :param b_threshold_factor: A multiplier for the standard deviation of
                                 the B-field derivative. A larger value makes
                                 the detection less sensitive to minor
                                 fluctuations. Defaults to 2.5.
      :type b_threshold_factor: float
      :param verbose: If True, prints diagnostic information. Defaults to False.
      :type verbose: bool

      :returns:

                The time of the shock crossing in seconds. Returns None if
                            no significant crossing is detected based on the criteria.
      :rtype: float or None



   .. py:method:: get_shock_up_down_states(pids, delta_t_up=20.0, delta_t_down=40.0, b_threshold_factor=2.5, verbose=False)

      Analyzes particles to find their state upstream and downstream of a shock.

      This function iterates through a list of particle IDs. For each particle, it
      first identifies the shock crossing time. It then calculates specific upstream
      and downstream time points based on this crossing. Finally, it interpolates
      the particle's full state (position, velocity, fields) at these two points
      and collects the results.

      :param pids: A list of particle IDs (e.g., [(0, 1), (0, 2), ...]) to process.
      :type pids: list
      :param delta_t_up: The time in seconds *before* the shock crossing to define
                         the upstream point. Defaults to 20.0.
      :type delta_t_up: float
      :param delta_t_down: The time in seconds *after* the shock crossing to define
                           the downstream point. Defaults to 40.0.
      :type delta_t_down: float
      :param b_threshold_factor: The sensitivity factor for shock detection, passed to
                                 `find_shock_crossing_time`. Defaults to 2.5.
      :type b_threshold_factor: float
      :param verbose: If True, prints progress and individual shock detection times.
                      Defaults to False.
      :type verbose: bool

      :returns:

                A tuple containing two Polars DataFrames:
                    - The first DataFrame contains the states of all valid particles at their
                      respective upstream times.
                    - The second DataFrame contains the states of all valid particles at their
                      respective downstream times.
                Each DataFrame includes the original particle ID (`pid_rank`, `pid_idx`), the
                shock crossing time (`t_cross`), and the interpolated physical quantities.
                Returns (None, None) if no particles with a valid shock crossing are found.
      :rtype: tuple[pl.DataFrame, pl.DataFrame]



   .. py:method:: _get_HT_frame(upstream_df: polars.DataFrame, downstream_df: polars.DataFrame) -> tuple[numpy.ndarray | None, numpy.ndarray | None]

      Finds the de Hoffmann-Teller frame velocity and the shock normal vector
      using the method from Sonnerup et al. [2006], which minimizes the
      residual electric field.

      :param upstream_df: DataFrame with upstream particle states.
      :type upstream_df: pl.DataFrame
      :param downstream_df: DataFrame with downstream particle states.
      :type downstream_df: pl.DataFrame

      :returns:

                A tuple containing:
                    - V_HT (np.ndarray | None): The de Hoffmann-Teller velocity vector
                      in [km/s] if successful, otherwise None.
                    - shock_normal (np.ndarray | None): The estimated shock normal
                      vector if successful, otherwise None.
      :rtype: tuple[np.ndarray | None, np.ndarray | None]



   .. py:method:: analyze_in_HT_frame(pID: Tuple[int, int], outname: str = None, verbose: bool = False)

      Analyzes a particle's trajectory in the de Hoffmann-Teller (HT) frame.

      This method performs the following steps:
      1. Finds the shock crossing and determines the upstream and downstream states.
      2. Calculates the de Hoffmann-Teller velocity (V_HT) and the shock normal.
      3. Transforms the particle's velocity and the electric/magnetic fields
         into the HT frame.
      4. In this frame, the energy gain is a direct measure of non-ideal
         acceleration. It calculates and plots this energy gain.
      5. Generates a summary plot of the analysis.

      :param pID: The particle ID (cpu, id) to analyze.
      :type pID: Tuple[int, int]
      :param outname: If provided, the plot is saved to this
                      filename. Defaults to None (displays plot).
      :type outname: str, optional
      :param verbose: If True, prints diagnostic information.
                      Defaults to False.
      :type verbose: bool, optional



   .. py:method:: plot_trajectory(pID: Tuple[int, int], *, fscaling=1, smoothing_window=None, t_start=None, t_end=None, dt=None, outname=None, shock_time=None, type='quick', xaxis='t', yaxis='x', switchYZ=False, splitYZ=False, ax=None, verbose=True, **kwargs)

      Plots the trajectory and velocities of the particle pID.

      Example:
      >>> tp.plot_trajectory((3,15))



   .. py:method:: plot_location(pData: numpy.ndarray)

      Plot the location of particles pData.

      Examples:
      >>> ids, pData = tp.read_particles_at_time(3700, doSave=True)
      >>> f = tp.plot_location(pData)



   .. py:method:: _calculate_true_gc_trajectory(pt: polars.DataFrame, smoothing_gyro_periods: float) -> polars.DataFrame

      Calculates the 'true' guiding center trajectory by smoothing.



   .. py:method:: _integrate_velocity(v_series: polars.Series, initial_pos_series: polars.Series, dt_series: polars.Series) -> polars.Series
      :staticmethod:


      Integrates a velocity series using the trapezoidal rule.



   .. py:method:: _calculate_predicted_gc_trajectory(pt: polars.DataFrame, pID: Tuple[int, int]) -> Tuple[polars.Series, polars.Series, polars.Series]

      Calculates the predicted guiding center trajectory from theory.



   .. py:method:: _plot_gc_verification(pt: polars.DataFrame, pos_gc_true: polars.DataFrame, pos_gc_pred: Tuple[polars.Series, polars.Series, polars.Series], pID: Tuple[int, int])

      Plots the verification results.



   .. py:method:: verify_guiding_center_model(pID: Tuple[int, int], smoothing_gyro_periods=1.0)

      Verifies the guiding center model by comparing it against the full
      particle trajectory.

      This method performs the following steps:
      1. Calculates a "true" guiding center trajectory by applying a low-pass
         filter (moving average) to the full particle trajectory, smoothing
         out the gyromotion.
      2. Calculates a "predicted" guiding center trajectory by numerically
         integrating the guiding center velocity, which is the sum of the
         parallel velocity and all perpendicular drift velocities (E x B,
         gradient, curvature, and polarization).
      3. Generates a plot comparing the full trajectory, the "true" GC
         trajectory, and the "predicted" GC trajectory for each coordinate (X, Y, Z).

      A close overlap between the "true" and "predicted" trajectories
      validates the guiding center approximation and the drift calculations.

      :param pID: The ID of the particle to analyze.
      :type pID: Tuple[int, int]
      :param smoothing_gyro_periods: The size of the moving average window
                                     in units of gyro-periods. Defaults to 1.0.
      :type smoothing_gyro_periods: float



.. py:class:: AMReXParticleData(output_dir: Union[str, pathlib.Path])

   This class provides an interface to the particle data in a plotfile.
   Data is loaded lazily upon first access to `idata` or `rdata`.


   .. py:attribute:: output_dir
      :type:  pathlib.Path


   .. py:attribute:: ptype
      :type:  str


   .. py:attribute:: _idata
      :type:  Optional[numpy.ndarray]


   .. py:attribute:: _rdata
      :type:  Optional[numpy.ndarray]


   .. py:attribute:: level_boxes
      :type:  List[List[Tuple[Tuple[int, Ellipsis], Tuple[int, Ellipsis]]]]


   .. py:attribute:: header
      :type:  AMReXParticleHeader


   .. py:attribute:: dim
      :type:  int


   .. py:attribute:: time
      :type:  float


   .. py:attribute:: left_edge
      :type:  List[float]


   .. py:attribute:: right_edge
      :type:  List[float]


   .. py:attribute:: domain_dimensions
      :type:  List[int]


   .. py:method:: _load_data() -> None

      Loads the particle data from disk if it has not been loaded yet.



   .. py:property:: idata
      :type: numpy.ndarray


      Lazily loads and returns the integer particle data.


   .. py:property:: rdata
      :type: numpy.ndarray


      Lazily loads and returns the real particle data.


   .. py:method:: _parse_main_header() -> None


   .. py:method:: _parse_particle_h_files() -> None

      Parses the Particle_H files to get the box arrays for each level.



   .. py:method:: __repr__() -> str


   .. py:method:: select_particles_in_region(x_range: Optional[Tuple[float, float]] = None, y_range: Optional[Tuple[float, float]] = None, z_range: Optional[Tuple[float, float]] = None) -> numpy.ndarray

      Selectively loads real component data for particles that fall within a
      specified rectangular region.

      This method first converts the physical range into an index-based range,
      then identifies which grid files intersect with that range, and finally
      reads only the necessary data. This avoids loading the entire dataset
      into memory. Integer data is skipped for efficiency.

      :param x_range: A tuple (min, max) for the x-axis boundary.
      :type x_range: tuple, optional
      :param y_range: A tuple (min, max) for the y-axis boundary.
      :type y_range: tuple, optional
      :param z_range: A tuple (min, max) for the z-axis boundary.
                      For 2D data, this is ignored.
      :type z_range: tuple, optional

      :returns:

                A numpy array containing the real data for the
                            selected particles.
      :rtype: np.ndarray



   .. py:method:: plot_phase(x_variable: str, y_variable: str, bins: Union[int, Tuple[int, int]] = 100, hist_range: Optional[List[List[float]]] = None, x_range: Optional[Tuple[float, float]] = None, y_range: Optional[Tuple[float, float]] = None, z_range: Optional[Tuple[float, float]] = None, normalize: bool = False, title: Optional[str] = None, xlabel: Optional[str] = None, ylabel: Optional[str] = None, **imshow_kwargs: Any) -> Optional[Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]]

      Plots the 2D phase space distribution for any two selected variables.

      This function creates a 2D weighted histogram to visualize the particle
      density. If a 'weight' component is present in the data, it will be
      used for the histogram weighting. Otherwise, a standard (unweighted)
      histogram is generated.

      :param x_variable: The name of the variable for the x-axis.
      :type x_variable: str
      :param y_variable: The name of the variable for the y-axis.
      :type y_variable: str
      :param bins: The number of bins. This can be a
                   single integer for the same number of
                   bins in each dimension, or a two-element
                   tuple for different numbers of bins in the
                   x and y dimension, respectively.
                   Defaults to 100.
      :type bins: int or tuple, optional
      :param hist_range: The leftmost and rightmost edges of the
                         bins along each dimension. It should be
                         in the format [[xmin, xmax], [ymin, ymax]].
                         Defaults to None.
      :type hist_range: list of lists, optional
      :param x_range: A tuple (min, max) for the x-axis boundary.
      :type x_range: tuple, optional
      :param y_range: A tuple (min, max) for the y-axis boundary.
      :type y_range: tuple, optional
      :param z_range: A tuple (min, max) for the z-axis boundary.
                      For 2D data, this is ignored.
      :type z_range: tuple, optional
      :param normalize: If True, the histogram is normalized to
                        form a probability density. Defaults to False.
      :type normalize: bool, optional
      :param title: The title for the plot. Defaults to "Phase Space Distribution".
      :type title: str, optional
      :param xlabel: The label for the x-axis. Defaults to `x_variable`.
      :type xlabel: str, optional
      :param ylabel: The label for the y-axis. Defaults to `y_variable`.
      :type ylabel: str, optional
      :param \*\*imshow_kwargs: Additional keyword arguments to be passed to `ax.imshow()`.
                                This can be used to control colormaps (`cmap`), normalization (`norm`), etc.

      :returns:

                A tuple containing the matplotlib figure and axes objects (`fig`, `ax`).
                       This allows for further customization of the plot after its creation.
      :rtype: tuple



.. py:function:: load(filename: str, iDomain: int = 0, iSpecies: int = 0, iFile: int = 0, readFieldData: bool = False, use_yt_loader: bool = False)

   Load FLEKS data.

   :param filename: Input file name pattern.
   :type filename: str
   :param iDomain: Test particle domain index. Defaults to 0.
   :type iDomain: int, optional
   :param iSpecies: Test particle species index. Defaults to 0.
   :type iSpecies: int, optional
   :param iFile: The index of the file to load if the pattern
                 matches multiple files. Defaults to 0.
   :type iFile: int, optional
   :param readFieldData: Whether or not to read field data for test particles. Defaults to False.
   :type readFieldData: bool, optional
   :param use_yt_loader: If True, forces the use of the yt loader for AMReX data. Defaults to False.
   :type use_yt_loader: bool, optional

   :returns: xarray.Dataset, YtFLEKSData, or FLEKSTP
   :rtype: FLEKS data


