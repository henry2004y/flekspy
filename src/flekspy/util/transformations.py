import numpy as np
from typing import List, Tuple, Callable


def create_field_transform(
    b_field: np.ndarray,
    original_component_names: List[str],
    vx_name: str = "velocity_x",
    vy_name: str = "velocity_y",
    vz_name: str = "velocity_z",
) -> Callable[[np.ndarray], Tuple[np.ndarray, List[str]]]:
    """
    Creates a transformation function to align velocity coordinates with a magnetic field.

    This function returns a new transformation function that can be passed to plotter methods.
    The returned function takes a data array, calculates the velocity components parallel
    and perpendicular to the given magnetic field, and returns a new data array containing
    the original data *without* the old velocity components, but with the new B-aligned
    components appended.

    Args:
        b_field (np.ndarray): The magnetic field vector (3 components).
        original_component_names (List[str]): The list of component names for the input data array.
        vx_name (str, optional): The name of the x-velocity component. Defaults to "velocity_x".
        vy_name (str, optional): The name of the y-velocity component. Defaults to "velocity_y".
        vz_name (str, optional): The name of the z-velocity component. Defaults to "velocity_z".

    Returns:
        A transformation function that takes a NumPy array and returns a tuple containing
        the transformed data array and the new list of component names.
    """
    if b_field.shape != (3,):
        raise ValueError(f"b_field must be a 3-component vector, but got shape {b_field.shape}")

    def field_transform(data: np.ndarray) -> Tuple[np.ndarray, List[str]]:
        """The actual transformation function generated by the factory."""
        component_map = {name: i for i, name in enumerate(original_component_names)}

        # Ensure all required velocity components are present
        required_vel_comps = {vx_name, vy_name, vz_name}
        if not required_vel_comps.issubset(component_map):
            missing_comps = required_vel_comps - set(component_map)
            raise ValueError(
                f"Velocity components {missing_comps} not found in component names: {original_component_names}"
            )

        # Get velocity data using indices
        vx_idx, vy_idx, vz_idx = (
            component_map[vx_name],
            component_map[vy_name],
            component_map[vz_name],
        )
        vx, vy, vz = data[:, vx_idx], data[:, vy_idx], data[:, vz_idx]

        # --- Perform the transformation ---
        b_hat = b_field / np.linalg.norm(b_field)

        # Calculate the velocity component parallel to B
        v_parallel = vx * b_hat[0] + vy * b_hat[1] + vz * b_hat[2]

        # Calculate the magnitude of the velocity component perpendicular to B
        v_mag_sq = vx**2 + vy**2 + vz**2
        v_perp_sq = v_mag_sq - v_parallel**2
        v_perp = np.sqrt(np.maximum(0, v_perp_sq))

        # --- Construct the new data array ---
        # Identify columns to keep (everything except the old velocities)
        velocity_indices = {vx_idx, vy_idx, vz_idx}
        keep_indices = [
            i for i in range(data.shape[1]) if i not in velocity_indices
        ]

        # Create the new data array by combining the kept columns with the new ones
        kept_data = data[:, keep_indices]
        transformed_data = np.c_[kept_data, v_parallel, v_perp]

        # --- Update component names ---
        kept_names = [
            name
            for i, name in enumerate(original_component_names)
            if i in keep_indices
        ]
        new_component_names = kept_names + ["v_parallel", "v_perp"]

        return transformed_data, new_component_names

    return field_transform
